algorithm draw_line_module( // reset and clk are generated by Silice
  input   uint1  start,  // start line drawing
  input   uint1  oe,     // output enable
  input   int16  x0,     // point 0
  input   int16  y0,     // point 0
  input   int16  x1,     // point 1
  input   int16  y1,     // point 1
  output! int16  x,      // drawing position
  output! int16  y,      // drawing position
  output! uint1  drawing, // actively drawing
  output! uint1  busy,   // drawing request in progress
  output! uint1  done_org     // drawing is complete (high for one tick)
) <autorun> { ////////////////// line properties //////////////////////
  uint1 swap= uninitialized; uint1 right= uninitialized;
  int16  xa= uninitialized;  /* start point*/           int16 ya= uninitialized; // start point
  int16  xb= uninitialized;  /* end point*/             int16 yb= uninitialized; // end point
  int16  x_end= uninitialized;  /* register end point*/ int16 y_end= uninitialized; // register end point
  ////////////////  error values ///////////////////////////
  int16 err= 0;  int16 dx= 0;  int16 dy= 0;
  uint1 movx= 0;   /* horizontal/vertical move required */ uint1 movy= 0; 
  uint1 state_draw =0; 
  while (1) {
    swap := (y0 > y1);  // always assignment 
    xa := swap ? x1 : x0;
    xb := swap ? x0 : x1;
    ya := swap ? y1 : y0;
    yb := swap ? y0 : y1;
    movx := (2*err >= dy);
    movy := (2*err <= dx);
    drawing := (state_draw == 1 && oe);
    if (reset) 
    {
      busy = 0;
      done_org = 0;
      goto IDLE;
    }
    IDLE:
      done_org = 0;
	    state_draw =0; 
      if (start == 1) {
        right = (xa < xb); // draw right to left?
        busy = 1;
        goto INIT_0;
      }
      else {goto IDLE;}   
    INIT_0: ///////////// state INIT_0
      state_draw =0; 
      dx = right ? xb - xa : xa - xb;  // dx = abs(xb - xa)
      dy = ya - yb;  // dy = -abs(yb - ya)
      goto INIT_1;

    INIT_1:///////////// state INIT_1
	    state_draw =0; 
      err = dx + dy;
      x = xa;
      y = ya;
      x_end = xb;
      y_end = yb;
      goto DRAW;
    DRAW:///////////// state Draw
	    state_draw =1; 
      if (oe) {
        if (x == x_end && y == y_end)
        {
         busy = 0;
         done_org = 1;
         state_draw =0;
         drawing=0;
         goto IDLE;
        }
        else 
        { 
          if (movx && movy)
          {
            x = right ? x + 1 : x - 1;
            y = y + 1;
            err = err+  dy + dx  ;  // Calculate next_err
          }
          else  
          {
            if(movx==1 && movy ==0)
            {
              x = right ? x + 1 : x - 1;
              err =err+ dy;  // Calculate next_err
            }
            else
            {
              if(movx==0 && movy ==1)
              {
              y = y + 1;  // always down
              err =err + dx;  // Calculate next_err
              }
            }
          }
          goto DRAW;
        }      
      }
    else {goto DRAW;}
  }
}
